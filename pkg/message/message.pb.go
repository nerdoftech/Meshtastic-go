// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.25.0-devel
// 	protoc        v3.7.1
// source: mesh.proto

package message

import (
	reflect "reflect"
	sync "sync"

	proto "github.com/golang/protobuf/proto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

type RouteError int32

const (
	RouteError_NONE RouteError = 0
	// Our node doesn't have a route to the requested destination anymore.
	RouteError_NO_ROUTE RouteError = 1
	// We received a nak while trying to forward on your behalf
	RouteError_GOT_NAK RouteError = 2
	RouteError_TIMEOUT RouteError = 3
)

// Enum value maps for RouteError.
var (
	RouteError_name = map[int32]string{
		0: "NONE",
		1: "NO_ROUTE",
		2: "GOT_NAK",
		3: "TIMEOUT",
	}
	RouteError_value = map[string]int32{
		"NONE":     0,
		"NO_ROUTE": 1,
		"GOT_NAK":  2,
		"TIMEOUT":  3,
	}
)

func (x RouteError) Enum() *RouteError {
	p := new(RouteError)
	*p = x
	return p
}

func (x RouteError) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RouteError) Descriptor() protoreflect.EnumDescriptor {
	return file_mesh_proto_enumTypes[0].Descriptor()
}

func (RouteError) Type() protoreflect.EnumType {
	return &file_mesh_proto_enumTypes[0]
}

func (x RouteError) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RouteError.Descriptor instead.
func (RouteError) EnumDescriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{0}
}

/// Shared constants between device and phone
type Constants int32

const (
	Constants_Unused Constants = 0 // First enum must be zero, and we are just using this enum to
)

// Enum value maps for Constants.
var (
	Constants_name = map[int32]string{
		0: "Unused",
	}
	Constants_value = map[string]int32{
		"Unused": 0,
	}
)

func (x Constants) Enum() *Constants {
	p := new(Constants)
	*p = x
	return p
}

func (x Constants) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Constants) Descriptor() protoreflect.EnumDescriptor {
	return file_mesh_proto_enumTypes[1].Descriptor()
}

func (Constants) Type() protoreflect.EnumType {
	return &file_mesh_proto_enumTypes[1]
}

func (x Constants) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Constants.Descriptor instead.
func (Constants) EnumDescriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{1}
}

type Data_Type int32

const (
	/// A message sent from a device outside of the mesh, in a form the mesh
	/// does not understand
	Data_OPAQUE Data_Type = 0 // NOTE: This must be 0, because it is documented in
	/// a simple UTF-8 text message, which even the little micros in the mesh
	/// can understand and show on their screen eventually in some circumstances
	/// even signal might send messages in this form (see below)
	Data_CLEAR_TEXT Data_Type = 1
	/// a message receive acknowledgement, sent in cleartext - allows radio to
	/// show user that a message has been read by the recipient, optional
	Data_CLEAR_READACK Data_Type = 2
)

// Enum value maps for Data_Type.
var (
	Data_Type_name = map[int32]string{
		0: "OPAQUE",
		1: "CLEAR_TEXT",
		2: "CLEAR_READACK",
	}
	Data_Type_value = map[string]int32{
		"OPAQUE":        0,
		"CLEAR_TEXT":    1,
		"CLEAR_READACK": 2,
	}
)

func (x Data_Type) Enum() *Data_Type {
	p := new(Data_Type)
	*p = x
	return p
}

func (x Data_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Data_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_mesh_proto_enumTypes[2].Descriptor()
}

func (Data_Type) Type() protoreflect.EnumType {
	return &file_mesh_proto_enumTypes[2]
}

func (x Data_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Data_Type.Descriptor instead.
func (Data_Type) EnumDescriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{1, 0}
}

type ChannelSettings_ModemConfig int32

const (
	// Note: these mappings must match ModemConfigChoice in the device code.
	ChannelSettings_Bw125Cr45Sf128 ChannelSettings_ModemConfig = 0 ///< Bw = 125 kHz, Cr = 4/5, Sf = 128chips/symbol, CRC
	///< on. Default medium range
	ChannelSettings_Bw500Cr45Sf128 ChannelSettings_ModemConfig = 1 ///< Bw = 500 kHz, Cr = 4/5, Sf = 128chips/symbol, CRC
	///< on. Fast+short range
	ChannelSettings_Bw31_25Cr48Sf512 ChannelSettings_ModemConfig = 2 ///< Bw = 31.25 kHz, Cr = 4/8, Sf = 512chips/symbol,
	///< CRC on. Slow+long range
	ChannelSettings_Bw125Cr48Sf4096 ChannelSettings_ModemConfig = 3 ///< Bw = 125 kHz, Cr = 4/8, Sf = 4096chips/symbol, CRC
)

// Enum value maps for ChannelSettings_ModemConfig.
var (
	ChannelSettings_ModemConfig_name = map[int32]string{
		0: "Bw125Cr45Sf128",
		1: "Bw500Cr45Sf128",
		2: "Bw31_25Cr48Sf512",
		3: "Bw125Cr48Sf4096",
	}
	ChannelSettings_ModemConfig_value = map[string]int32{
		"Bw125Cr45Sf128":   0,
		"Bw500Cr45Sf128":   1,
		"Bw31_25Cr48Sf512": 2,
		"Bw125Cr48Sf4096":  3,
	}
)

func (x ChannelSettings_ModemConfig) Enum() *ChannelSettings_ModemConfig {
	p := new(ChannelSettings_ModemConfig)
	*p = x
	return p
}

func (x ChannelSettings_ModemConfig) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ChannelSettings_ModemConfig) Descriptor() protoreflect.EnumDescriptor {
	return file_mesh_proto_enumTypes[3].Descriptor()
}

func (ChannelSettings_ModemConfig) Type() protoreflect.EnumType {
	return &file_mesh_proto_enumTypes[3]
}

func (x ChannelSettings_ModemConfig) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ChannelSettings_ModemConfig.Descriptor instead.
func (ChannelSettings_ModemConfig) EnumDescriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{6, 0}
}

// a gps position
type Position struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//* The new preferred location encoding, divide by 10e-7 to get degrees in
	// floating point
	LatitudeI    int32 `protobuf:"zigzag32,7,opt,name=latitude_i,json=latitudeI,proto3" json:"latitude_i,omitempty"`
	LongitudeI   int32 `protobuf:"zigzag32,8,opt,name=longitude_i,json=longitudeI,proto3" json:"longitude_i,omitempty"`
	Altitude     int32 `protobuf:"varint,3,opt,name=altitude,proto3" json:"altitude,omitempty"`
	BatteryLevel int32 `protobuf:"varint,4,opt,name=battery_level,json=batteryLevel,proto3" json:"battery_level,omitempty"` // 1-100 (0 means not provided)
	/// This is usually not sent over the mesh (to save space), but it is sent
	/// from the phone so that the local device can set its RTC If it is sent over
	/// the mesh (because there are devices on the mesh without GPS), it will only
	/// be sent by devices which has a hardware GPS clock.
	Time uint32 `protobuf:"fixed32,9,opt,name=time,proto3" json:"time,omitempty"` // seconds since 1970
}

func (x *Position) Reset() {
	*x = Position{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Position) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Position) ProtoMessage() {}

func (x *Position) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Position.ProtoReflect.Descriptor instead.
func (*Position) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{0}
}

func (x *Position) GetLatitudeI() int32 {
	if x != nil {
		return x.LatitudeI
	}
	return 0
}

func (x *Position) GetLongitudeI() int32 {
	if x != nil {
		return x.LongitudeI
	}
	return 0
}

func (x *Position) GetAltitude() int32 {
	if x != nil {
		return x.Altitude
	}
	return 0
}

func (x *Position) GetBatteryLevel() int32 {
	if x != nil {
		return x.BatteryLevel
	}
	return 0
}

func (x *Position) GetTime() uint32 {
	if x != nil {
		return x.Time
	}
	return 0
}

// a data message to forward to an external app (or possibly also be consumed
// internally in the case of CLEAR_TEXT and CLEAR_READACK
type Data struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Typ     Data_Type `protobuf:"varint,1,opt,name=typ,proto3,enum=Data_Type" json:"typ,omitempty"` // required
	Payload []byte    `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`         // required
}

func (x *Data) Reset() {
	*x = Data{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Data) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Data) ProtoMessage() {}

func (x *Data) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Data.ProtoReflect.Descriptor instead.
func (*Data) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{1}
}

func (x *Data) GetTyp() Data_Type {
	if x != nil {
		return x.Typ
	}
	return Data_OPAQUE
}

func (x *Data) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

// Broadcast when a newly powered mesh node wants to find a node num it can use
//// Sent from the phone over bluetooth to set the user id for the owner of this
//node.
//// Also sent from nodes to each other when a new node signs on (so all clients
//can have this info)
//
//The algorithm is as follows:
// when a node starts up, it broadcasts their user and the normal flow is for all
//other nodes to reply with their User as well (so the new node can build its node
//db)
// If a node ever receives a User (not just the first broadcast) message where
//the sender node number equals our node number, that indicates a collision has
//occurred and the following steps should happen:
//
//If the receiving node (that was already in the mesh)'s macaddr is LOWER than the
//new User who just tried to sign in: it gets to keep its nodenum.  We send a
//broadcast message of OUR User (we use a broadcast so that the other node can
//receive our message, considering we have the same id - it also serves to let
//observers correct their nodedb) - this case is rare so it should be okay.
//
//If any node receives a User where the macaddr is GTE than their local macaddr,
//they have been vetoed and should pick a new random nodenum (filtering against
//whatever it knows about the nodedb) and rebroadcast their User.
//
//A few nodenums are reserved and will never be requested:
//0xff - broadcast
//0 through 3 - for future use
//
type User struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"` // a globally unique ID string for this user.  In the case of
	// Signal that would mean +16504442323, for the default macaddr
	// derived id it would be !<6 hexidecimal bytes>
	LongName  string `protobuf:"bytes,2,opt,name=long_name,json=longName,proto3" json:"long_name,omitempty"`    // A full name for this user, i.e. "Kevin Hester"
	ShortName string `protobuf:"bytes,3,opt,name=short_name,json=shortName,proto3" json:"short_name,omitempty"` // A VERY short name, ideally two characters.  Suitable
	// for a tiny OLED screen
	Macaddr []byte `protobuf:"bytes,4,opt,name=macaddr,proto3" json:"macaddr,omitempty"` // This is the addr of the radio.  Not populated by the
}

func (x *User) Reset() {
	*x = User{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *User) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*User) ProtoMessage() {}

func (x *User) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use User.ProtoReflect.Descriptor instead.
func (*User) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{2}
}

func (x *User) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *User) GetLongName() string {
	if x != nil {
		return x.LongName
	}
	return ""
}

func (x *User) GetShortName() string {
	if x != nil {
		return x.ShortName
	}
	return ""
}

func (x *User) GetMacaddr() []byte {
	if x != nil {
		return x.Macaddr
	}
	return nil
}

/// A message used in our Dynamic Source Routing protocol (RFC 4728 based)
type RouteDiscovery struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//*
	//The list of nodes this packet has visited so far
	Route []int32 `protobuf:"varint,2,rep,packed,name=route,proto3" json:"route,omitempty"`
}

func (x *RouteDiscovery) Reset() {
	*x = RouteDiscovery{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RouteDiscovery) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteDiscovery) ProtoMessage() {}

func (x *RouteDiscovery) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteDiscovery.ProtoReflect.Descriptor instead.
func (*RouteDiscovery) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{3}
}

func (x *RouteDiscovery) GetRoute() []int32 {
	if x != nil {
		return x.Route
	}
	return nil
}

// The payload portion fo a packet, this is the actual bytes that are sent
// inside a radio packet (because from/to are broken out by the comms library)
type SubPacket struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Only one of the following fields can be populated at a time
	//
	// Types that are assignable to Payload:
	//	*SubPacket_Position
	//	*SubPacket_Data
	//	*SubPacket_User
	//	*SubPacket_RouteRequest
	//	*SubPacket_RouteReply
	//	*SubPacket_RouteError
	Payload isSubPacket_Payload `protobuf_oneof:"payload"`
	/// Not normally used, but for testing a sender can request that recipient
	/// responds in kind (i.e. if it received a position, it should unicast back
	/// its position).
	// Note: that if you set this on a broadcast you will receive many replies.
	// FIXME - unify (i.e. remove) this with the new reliable messaging at the
	// MeshPacket level
	WantResponse bool `protobuf:"varint,5,opt,name=want_response,json=wantResponse,proto3" json:"want_response,omitempty"`
	// Types that are assignable to Ack:
	//	*SubPacket_SuccessId
	//	*SubPacket_FailId
	Ack isSubPacket_Ack `protobuf_oneof:"ack"`
	//*
	//The address of the destination node.
	//
	//This field is is filled in by the mesh radio device software, applicaiton
	//layer software should never need it.
	//
	//RouteDiscovery messages _must_ populate this.  Other message types might need
	//to if they are doing multihop routing.
	Dest uint32 `protobuf:"varint,9,opt,name=dest,proto3" json:"dest,omitempty"`
	//*
	//The address of the original sender for this message.
	//
	//This field should _only_ be populated for reliable multihop packets (to keep
	//packets small).
	Source uint32 `protobuf:"varint,12,opt,name=source,proto3" json:"source,omitempty"`
	//*
	//Only used in route_error messages.  Indicates the original message ID that
	//this message is reporting failure on.
	OriginalId uint32 `protobuf:"varint,2,opt,name=original_id,json=originalId,proto3" json:"original_id,omitempty"`
}

func (x *SubPacket) Reset() {
	*x = SubPacket{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SubPacket) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubPacket) ProtoMessage() {}

func (x *SubPacket) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubPacket.ProtoReflect.Descriptor instead.
func (*SubPacket) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{4}
}

func (m *SubPacket) GetPayload() isSubPacket_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (x *SubPacket) GetPosition() *Position {
	if x, ok := x.GetPayload().(*SubPacket_Position); ok {
		return x.Position
	}
	return nil
}

func (x *SubPacket) GetData() *Data {
	if x, ok := x.GetPayload().(*SubPacket_Data); ok {
		return x.Data
	}
	return nil
}

func (x *SubPacket) GetUser() *User {
	if x, ok := x.GetPayload().(*SubPacket_User); ok {
		return x.User
	}
	return nil
}

func (x *SubPacket) GetRouteRequest() *RouteDiscovery {
	if x, ok := x.GetPayload().(*SubPacket_RouteRequest); ok {
		return x.RouteRequest
	}
	return nil
}

func (x *SubPacket) GetRouteReply() *RouteDiscovery {
	if x, ok := x.GetPayload().(*SubPacket_RouteReply); ok {
		return x.RouteReply
	}
	return nil
}

func (x *SubPacket) GetRouteError() RouteError {
	if x, ok := x.GetPayload().(*SubPacket_RouteError); ok {
		return x.RouteError
	}
	return RouteError_NONE
}

func (x *SubPacket) GetWantResponse() bool {
	if x != nil {
		return x.WantResponse
	}
	return false
}

func (m *SubPacket) GetAck() isSubPacket_Ack {
	if m != nil {
		return m.Ack
	}
	return nil
}

func (x *SubPacket) GetSuccessId() uint32 {
	if x, ok := x.GetAck().(*SubPacket_SuccessId); ok {
		return x.SuccessId
	}
	return 0
}

func (x *SubPacket) GetFailId() uint32 {
	if x, ok := x.GetAck().(*SubPacket_FailId); ok {
		return x.FailId
	}
	return 0
}

func (x *SubPacket) GetDest() uint32 {
	if x != nil {
		return x.Dest
	}
	return 0
}

func (x *SubPacket) GetSource() uint32 {
	if x != nil {
		return x.Source
	}
	return 0
}

func (x *SubPacket) GetOriginalId() uint32 {
	if x != nil {
		return x.OriginalId
	}
	return 0
}

type isSubPacket_Payload interface {
	isSubPacket_Payload()
}

type SubPacket_Position struct {
	Position *Position `protobuf:"bytes,1,opt,name=position,proto3,oneof"`
}

type SubPacket_Data struct {
	Data *Data `protobuf:"bytes,3,opt,name=data,proto3,oneof"`
}

type SubPacket_User struct {
	User *User `protobuf:"bytes,4,opt,name=user,proto3,oneof"`
}

type SubPacket_RouteRequest struct {
	//*
	//A route request going from the requester
	RouteRequest *RouteDiscovery `protobuf:"bytes,6,opt,name=route_request,json=routeRequest,proto3,oneof"`
}

type SubPacket_RouteReply struct {
	//*
	//A route reply
	RouteReply *RouteDiscovery `protobuf:"bytes,7,opt,name=route_reply,json=routeReply,proto3,oneof"`
}

type SubPacket_RouteError struct {
	//*
	//A failure in a routed message
	RouteError RouteError `protobuf:"varint,13,opt,name=route_error,json=routeError,proto3,enum=RouteError,oneof"`
}

func (*SubPacket_Position) isSubPacket_Payload() {}

func (*SubPacket_Data) isSubPacket_Payload() {}

func (*SubPacket_User) isSubPacket_Payload() {}

func (*SubPacket_RouteRequest) isSubPacket_Payload() {}

func (*SubPacket_RouteReply) isSubPacket_Payload() {}

func (*SubPacket_RouteError) isSubPacket_Payload() {}

type isSubPacket_Ack interface {
	isSubPacket_Ack()
}

type SubPacket_SuccessId struct {
	//*
	//This packet is a requested acknoledgement indicating that we have received
	//the specified message ID.  This packet type can be used both for immediate
	//(0 hops) messages or can be routed through multiple hops if dest is set.
	//
	//Note: As an optimization, recipients can _also_ populate a field in payload
	//if they think the recipient would appreciate that extra state.
	SuccessId uint32 `protobuf:"varint,10,opt,name=success_id,json=successId,proto3,oneof"`
}

type SubPacket_FailId struct {
	//* This is a nak, we failed to deliver this message.
	FailId uint32 `protobuf:"varint,11,opt,name=fail_id,json=failId,proto3,oneof"`
}

func (*SubPacket_SuccessId) isSubPacket_Ack() {}

func (*SubPacket_FailId) isSubPacket_Ack() {}

// A full packet sent/received over the mesh
// Note: For simplicity reasons (and that we want to keep over the radio packets
// very small, we now assume that there is only _one_ SubPacket in each
// MeshPacket).
type MeshPacket struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//*
	//The sending node number.
	//
	//Note: Our crypto implementation uses this field as well.  See
	//docs/software/crypto.md for details.
	From uint32 `protobuf:"varint,1,opt,name=from,proto3" json:"from,omitempty"` // FIXME - really should be fixed32 instead, this encoding
	//*
	//The (immediate) destination for this packet.  If we are using routing, the
	//final destination will be in payload.dest
	To uint32 `protobuf:"varint,2,opt,name=to,proto3" json:"to,omitempty"` // FIXME - really should be fixed32 instead, this encoding only
	//*
	//Internally to the mesh radios we will route SubPackets encrypted per
	//docs/software/crypto.md.  However, when a particular node has the correct
	//key to decode a particular packet, it will decode the payload into a SubPacket
	//protobuf structure.
	//
	//Software outside of the device nodes will never encounter a packet where
	//"decoded" is not populated (i.e. any encryption/decryption happens before
	//reaching the applications)
	//
	//The numeric IDs for these fields were selected to keep backwards compatibility
	//with old applications.
	//
	// Types that are assignable to Payload:
	//	*MeshPacket_Decoded
	//	*MeshPacket_Encrypted
	Payload isMeshPacket_Payload `protobuf_oneof:"payload"`
	//*
	//A unique ID for this packet.  Always 0 for no-ack packets or non broadcast
	//packets (and therefore take zero bytes of space).  Otherwise a unique ID for
	//this packet.  Useful for flooding algorithms.
	//
	//ID only needs to be unique on a _per sender_ basis.   And it only
	//needs to be unique for a few minutes (long enough to last for the length of
	//any ACK or the completion of a mesh broadcast flood).
	//
	//Note: Our crypto implementation uses this id as well.  See
	//docs/software/crypto.md for details.
	Id uint32 `protobuf:"varint,6,opt,name=id,proto3" json:"id,omitempty"` // FIXME - really should be fixed32 instead, this encoding only
	/// The time this message was received by the esp32 (secs since 1970).  Note:
	/// this field is _never_ sent on the radio link itself (to save space) Times
	/// are typically not sent over the mesh, but they will be added to any Packet
	/// (chain of SubPacket) sent to the phone (so the phone can know exact time
	/// of reception)
	RxTime uint32 `protobuf:"fixed32,9,opt,name=rx_time,json=rxTime,proto3" json:"rx_time,omitempty"`
	/// *Never* sent over the radio links.  Set during reception to indicate the
	/// SNR
	/// of this packet.  Used to collect statistics on current link waulity.
	RxSnr float32 `protobuf:"fixed32,7,opt,name=rx_snr,json=rxSnr,proto3" json:"rx_snr,omitempty"`
	//*
	//If unset treated as zero (no fowarding, send to adjacent nodes only)
	//if 1, allow hopping through one node, etc...
	//
	//For our usecase real world topologies probably have a max of about 3.
	//
	//This field is normally placed into a few of bits in the header.
	HopLimit uint32 `protobuf:"varint,10,opt,name=hop_limit,json=hopLimit,proto3" json:"hop_limit,omitempty"`
	//*
	//This packet is being sent as a reliable message, we would prefer it to arrive
	//at the destination.  We would like to receive a ack packet in response.
	//
	//Broadcasts messages treat this flag specially: Since acks for broadcasts would
	//rapidly flood the channel, the normal ack behavior is suppressed.  Instead,
	//the original sender listens to see if at least one node is rebroadcasting this
	//packet (because naive flooding algoritm).  If it hears that the odds (given
	//typical LoRa topologies) the odds are very high that every node should
	//eventually receive the message.  So FloodingRouter.cpp generates an implicit
	//ack which is delivered to the original sender. If after some time we don't
	//hear anyone rebroadcast our packet, we will timeout and retransmit, using the
	//regular resend logic.
	//
	//Note: This flag is normally sent in a flag bit in the header when sent over
	//the wire
	WantAck bool `protobuf:"varint,11,opt,name=want_ack,json=wantAck,proto3" json:"want_ack,omitempty"`
}

func (x *MeshPacket) Reset() {
	*x = MeshPacket{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MeshPacket) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MeshPacket) ProtoMessage() {}

func (x *MeshPacket) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MeshPacket.ProtoReflect.Descriptor instead.
func (*MeshPacket) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{5}
}

func (x *MeshPacket) GetFrom() uint32 {
	if x != nil {
		return x.From
	}
	return 0
}

func (x *MeshPacket) GetTo() uint32 {
	if x != nil {
		return x.To
	}
	return 0
}

func (m *MeshPacket) GetPayload() isMeshPacket_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (x *MeshPacket) GetDecoded() *SubPacket {
	if x, ok := x.GetPayload().(*MeshPacket_Decoded); ok {
		return x.Decoded
	}
	return nil
}

func (x *MeshPacket) GetEncrypted() []byte {
	if x, ok := x.GetPayload().(*MeshPacket_Encrypted); ok {
		return x.Encrypted
	}
	return nil
}

func (x *MeshPacket) GetId() uint32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *MeshPacket) GetRxTime() uint32 {
	if x != nil {
		return x.RxTime
	}
	return 0
}

func (x *MeshPacket) GetRxSnr() float32 {
	if x != nil {
		return x.RxSnr
	}
	return 0
}

func (x *MeshPacket) GetHopLimit() uint32 {
	if x != nil {
		return x.HopLimit
	}
	return 0
}

func (x *MeshPacket) GetWantAck() bool {
	if x != nil {
		return x.WantAck
	}
	return false
}

type isMeshPacket_Payload interface {
	isMeshPacket_Payload()
}

type MeshPacket_Decoded struct {
	Decoded *SubPacket `protobuf:"bytes,3,opt,name=decoded,proto3,oneof"`
}

type MeshPacket_Encrypted struct {
	Encrypted []byte `protobuf:"bytes,8,opt,name=encrypted,proto3,oneof"`
}

func (*MeshPacket_Decoded) isMeshPacket_Payload() {}

func (*MeshPacket_Encrypted) isMeshPacket_Payload() {}

// Full settings (center freq, spread factor, pre-shared secret key etc...)
// needed to configure a radio for speaking on a particlar channel This
// information can be encoded as a QRcode/url so that other users can configure
// their radio to join the same channel.
type ChannelSettings struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	TxPower int32 `protobuf:"varint,1,opt,name=tx_power,json=txPower,proto3" json:"tx_power,omitempty"`
	/// This value replaces bandwidth/spread_factor/coding_rate.  If you'd like to
	/// experiment with other options add them to MeshRadio.cpp in the device
	/// code.
	ModemConfig ChannelSettings_ModemConfig `protobuf:"varint,3,opt,name=modem_config,json=modemConfig,proto3,enum=ChannelSettings_ModemConfig" json:"modem_config,omitempty"`
	/// A simple preshared key for now for crypto.  Must be either 0 bytes (no
	/// crypto), 16 bytes (AES128), or 32 bytes (AES256)
	Psk []byte `protobuf:"bytes,4,opt,name=psk,proto3" json:"psk,omitempty"`
	/// A SHORT name that will be packed into the URL.  Less than 12 bytes.
	/// Something for end users to call the channel
	Name string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
}

func (x *ChannelSettings) Reset() {
	*x = ChannelSettings{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ChannelSettings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChannelSettings) ProtoMessage() {}

func (x *ChannelSettings) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChannelSettings.ProtoReflect.Descriptor instead.
func (*ChannelSettings) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{6}
}

func (x *ChannelSettings) GetTxPower() int32 {
	if x != nil {
		return x.TxPower
	}
	return 0
}

func (x *ChannelSettings) GetModemConfig() ChannelSettings_ModemConfig {
	if x != nil {
		return x.ModemConfig
	}
	return ChannelSettings_Bw125Cr45Sf128
}

func (x *ChannelSettings) GetPsk() []byte {
	if x != nil {
		return x.Psk
	}
	return nil
}

func (x *ChannelSettings) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// The entire set of user settable/readable settings for our radio device.
// Includes both the current channel settings and any preferences the user has
// set for behavior of their node
type RadioConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Preferences     *RadioConfig_UserPreferences `protobuf:"bytes,1,opt,name=preferences,proto3" json:"preferences,omitempty"`
	ChannelSettings *ChannelSettings             `protobuf:"bytes,2,opt,name=channel_settings,json=channelSettings,proto3" json:"channel_settings,omitempty"`
}

func (x *RadioConfig) Reset() {
	*x = RadioConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RadioConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RadioConfig) ProtoMessage() {}

func (x *RadioConfig) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RadioConfig.ProtoReflect.Descriptor instead.
func (*RadioConfig) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{7}
}

func (x *RadioConfig) GetPreferences() *RadioConfig_UserPreferences {
	if x != nil {
		return x.Preferences
	}
	return nil
}

func (x *RadioConfig) GetChannelSettings() *ChannelSettings {
	if x != nil {
		return x.ChannelSettings
	}
	return nil
}

// Full information about a node on the mesh
type NodeInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Num  uint32 `protobuf:"varint,1,opt,name=num,proto3" json:"num,omitempty"` // the node number
	User *User  `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	/// This position data will also contain a time last seen
	Position *Position `protobuf:"bytes,3,opt,name=position,proto3" json:"position,omitempty"`
	/// Returns the Signal-to-noise ratio (SNR) of the last received message, as
	/// measured by the receiver. return SNR of the last received message in dB
	Snr float32 `protobuf:"fixed32,7,opt,name=snr,proto3" json:"snr,omitempty"`
	/// Our current preferred node node for routing - might be the same as num if
	/// we are adjacent Or zero if we don't yet know a route to this node.
	NextHop uint32 `protobuf:"varint,5,opt,name=next_hop,json=nextHop,proto3" json:"next_hop,omitempty"`
}

func (x *NodeInfo) Reset() {
	*x = NodeInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NodeInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeInfo) ProtoMessage() {}

func (x *NodeInfo) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeInfo.ProtoReflect.Descriptor instead.
func (*NodeInfo) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{8}
}

func (x *NodeInfo) GetNum() uint32 {
	if x != nil {
		return x.Num
	}
	return 0
}

func (x *NodeInfo) GetUser() *User {
	if x != nil {
		return x.User
	}
	return nil
}

func (x *NodeInfo) GetPosition() *Position {
	if x != nil {
		return x.Position
	}
	return nil
}

func (x *NodeInfo) GetSnr() float32 {
	if x != nil {
		return x.Snr
	}
	return 0
}

func (x *NodeInfo) GetNextHop() uint32 {
	if x != nil {
		return x.NextHop
	}
	return 0
}

//*
//Unique local debugging info for this node
//
//Note: we don't include position or the user info, because that will come in the
//
//Sent to the phone in response to WantNodes.
type MyNodeInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	/// Tells the phone what our node number is, default starting value is lowbyte
	/// of macaddr, but it will be fixed if that is already in use
	MyNodeNum uint32 `protobuf:"varint,1,opt,name=my_node_num,json=myNodeNum,proto3" json:"my_node_num,omitempty"`
	/// if false it would be great if the phone can help provide gps coordinates
	HasGps bool `protobuf:"varint,2,opt,name=has_gps,json=hasGps,proto3" json:"has_gps,omitempty"`
	/// # of legal channels (set at build time in the device flash image)
	NumChannels int32 `protobuf:"varint,3,opt,name=num_channels,json=numChannels,proto3" json:"num_channels,omitempty"`
	/// The region code for my radio (US, CN, etc...)
	Region string `protobuf:"bytes,4,opt,name=region,proto3" json:"region,omitempty"`
	/// TBEAM, HELTEC, etc...
	HwModel string `protobuf:"bytes,5,opt,name=hw_model,json=hwModel,proto3" json:"hw_model,omitempty"`
	/// 0.0.5 etc...
	FirmwareVersion string `protobuf:"bytes,6,opt,name=firmware_version,json=firmwareVersion,proto3" json:"firmware_version,omitempty"`
	/// An error message we'd like to report back to the mothership through
	/// analytics.  It indicates a serious bug occurred on the device, the device
	/// coped with it, but we still want to tell the devs about the bug. This
	/// field will be cleared after the phone reads MyNodeInfo (i.e. it will only
	/// be reported once) a numeric error code to go with error message, zero
	/// means no error
	ErrorCode uint32 `protobuf:"varint,7,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
	/// A numeric error address (nonzero if available)
	ErrorAddress uint32 `protobuf:"varint,8,opt,name=error_address,json=errorAddress,proto3" json:"error_address,omitempty"`
	/// The total number of errors this node has ever encountered (well - since
	/// the last time we discarded preferences)
	ErrorCount uint32 `protobuf:"varint,9,opt,name=error_count,json=errorCount,proto3" json:"error_count,omitempty"`
	//* How many bits are used for the packetid.  If zero it is assumed we use
	//eight bit packetids Old device loads (older that 0.6.5 do not populate this
	//field, but all newer loads do).
	PacketIdBits uint32 `protobuf:"varint,10,opt,name=packet_id_bits,json=packetIdBits,proto3" json:"packet_id_bits,omitempty"`
	//* The current ID this node is using for sending new packets (exposed so that
	//the phone can self assign packet IDs if it wishes by picking packet IDs from
	//the opposite side of the pacekt ID space).
	//
	//Old device loads (older that 0.6.5 do not populate this field, but all newer
	//loads do).
	//
	//FIXME: that we need to expose this is a bit of a mistake.  Really the phones
	//should be modeled/treated as 1st class nodes like any other, and the radio
	//connected to the phone just routes like any other. This would allow all sorts
	//of clean/clever routing topologies in the future.
	CurrentPacketId uint32 `protobuf:"varint,11,opt,name=current_packet_id,json=currentPacketId,proto3" json:"current_packet_id,omitempty"`
	//* How many bits are used for the nodenum.  If zero it is assumed we use
	//eight bit nodenums New device loads will user 32 bit nodenum.
	//Old device loads (older that 0.6.5 do not populate this field, but all newer
	//loads do).
	NodeNumBits uint32 `protobuf:"varint,12,opt,name=node_num_bits,json=nodeNumBits,proto3" json:"node_num_bits,omitempty"`
	//* How long before we consider a message abandoned and we can clear our
	//caches of any messages in flight Normally quite large to handle the worst case
	//message delivery time, 5 minutes.  Formerly called FLOOD_EXPIRE_TIME in the
	//device code
	MessageTimeoutMsec uint32 `protobuf:"varint,13,opt,name=message_timeout_msec,json=messageTimeoutMsec,proto3" json:"message_timeout_msec,omitempty"`
	//* The minimum app version that can talk to this device.  Android apps should
	//compare this to their build number and if too low tell the user they must
	//update their app
	MinAppVersion uint32 `protobuf:"varint,14,opt,name=min_app_version,json=minAppVersion,proto3" json:"min_app_version,omitempty"`
}

func (x *MyNodeInfo) Reset() {
	*x = MyNodeInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MyNodeInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MyNodeInfo) ProtoMessage() {}

func (x *MyNodeInfo) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MyNodeInfo.ProtoReflect.Descriptor instead.
func (*MyNodeInfo) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{9}
}

func (x *MyNodeInfo) GetMyNodeNum() uint32 {
	if x != nil {
		return x.MyNodeNum
	}
	return 0
}

func (x *MyNodeInfo) GetHasGps() bool {
	if x != nil {
		return x.HasGps
	}
	return false
}

func (x *MyNodeInfo) GetNumChannels() int32 {
	if x != nil {
		return x.NumChannels
	}
	return 0
}

func (x *MyNodeInfo) GetRegion() string {
	if x != nil {
		return x.Region
	}
	return ""
}

func (x *MyNodeInfo) GetHwModel() string {
	if x != nil {
		return x.HwModel
	}
	return ""
}

func (x *MyNodeInfo) GetFirmwareVersion() string {
	if x != nil {
		return x.FirmwareVersion
	}
	return ""
}

func (x *MyNodeInfo) GetErrorCode() uint32 {
	if x != nil {
		return x.ErrorCode
	}
	return 0
}

func (x *MyNodeInfo) GetErrorAddress() uint32 {
	if x != nil {
		return x.ErrorAddress
	}
	return 0
}

func (x *MyNodeInfo) GetErrorCount() uint32 {
	if x != nil {
		return x.ErrorCount
	}
	return 0
}

func (x *MyNodeInfo) GetPacketIdBits() uint32 {
	if x != nil {
		return x.PacketIdBits
	}
	return 0
}

func (x *MyNodeInfo) GetCurrentPacketId() uint32 {
	if x != nil {
		return x.CurrentPacketId
	}
	return 0
}

func (x *MyNodeInfo) GetNodeNumBits() uint32 {
	if x != nil {
		return x.NodeNumBits
	}
	return 0
}

func (x *MyNodeInfo) GetMessageTimeoutMsec() uint32 {
	if x != nil {
		return x.MessageTimeoutMsec
	}
	return 0
}

func (x *MyNodeInfo) GetMinAppVersion() uint32 {
	if x != nil {
		return x.MinAppVersion
	}
	return 0
}

// This message is never sent over the wire, but it is used for serializing DB
// state to flash in the device code
// FIXME, since we write this each time we enter deep sleep (and have infinite
// flash) it would be better to use some sort of append only data structure for
// the receive queue and use the preferences store for the other stuff
type DeviceState struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Radio *RadioConfig `protobuf:"bytes,1,opt,name=radio,proto3" json:"radio,omitempty"`
	/// Read only settings/info about this node
	MyNode *MyNodeInfo `protobuf:"bytes,2,opt,name=my_node,json=myNode,proto3" json:"my_node,omitempty"`
	/// My owner info
	Owner  *User       `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
	NodeDb []*NodeInfo `protobuf:"bytes,4,rep,name=node_db,json=nodeDb,proto3" json:"node_db,omitempty"`
	/// Received packets saved for delivery to the phone
	ReceiveQueue []*MeshPacket `protobuf:"bytes,5,rep,name=receive_queue,json=receiveQueue,proto3" json:"receive_queue,omitempty"`
	/// A version integer used to invalidate old save files when we make
	/// incompatible changes This integer is set at build time and is private to
	/// NodeDB.cpp in the device code.
	Version uint32 `protobuf:"varint,8,opt,name=version,proto3" json:"version,omitempty"`
	/// We keep the last received text message (only) stored in the device flash,
	/// so we can show it on the screen.  Might be null
	RxTextMessage *MeshPacket `protobuf:"bytes,7,opt,name=rx_text_message,json=rxTextMessage,proto3" json:"rx_text_message,omitempty"`
	/// Used only during development.  Indicates developer is testing and changes should never be saved to flash.
	NoSave bool `protobuf:"varint,9,opt,name=no_save,json=noSave,proto3" json:"no_save,omitempty"`
}

func (x *DeviceState) Reset() {
	*x = DeviceState{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DeviceState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeviceState) ProtoMessage() {}

func (x *DeviceState) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeviceState.ProtoReflect.Descriptor instead.
func (*DeviceState) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{10}
}

func (x *DeviceState) GetRadio() *RadioConfig {
	if x != nil {
		return x.Radio
	}
	return nil
}

func (x *DeviceState) GetMyNode() *MyNodeInfo {
	if x != nil {
		return x.MyNode
	}
	return nil
}

func (x *DeviceState) GetOwner() *User {
	if x != nil {
		return x.Owner
	}
	return nil
}

func (x *DeviceState) GetNodeDb() []*NodeInfo {
	if x != nil {
		return x.NodeDb
	}
	return nil
}

func (x *DeviceState) GetReceiveQueue() []*MeshPacket {
	if x != nil {
		return x.ReceiveQueue
	}
	return nil
}

func (x *DeviceState) GetVersion() uint32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *DeviceState) GetRxTextMessage() *MeshPacket {
	if x != nil {
		return x.RxTextMessage
	}
	return nil
}

func (x *DeviceState) GetNoSave() bool {
	if x != nil {
		return x.NoSave
	}
	return false
}

/// Debug output from the device
type DebugString struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *DebugString) Reset() {
	*x = DebugString{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DebugString) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DebugString) ProtoMessage() {}

func (x *DebugString) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DebugString.ProtoReflect.Descriptor instead.
func (*DebugString) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{11}
}

func (x *DebugString) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// packets from the radio to the phone will appear on the fromRadio
// characteristic.  It will support READ and NOTIFY.  When a new packet arrives
// the device will notify?  possibly identify instead? it will sit in that
// descriptor until consumed by the phone, at which point the next item in the
// FIFO will be populated.  FIXME
type FromRadio struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The packet num, used to allow the phone to request missing read packets
	// from the FIFO, see our bluetooth docs
	Num uint32 `protobuf:"varint,1,opt,name=num,proto3" json:"num,omitempty"`
	// Types that are assignable to Variant:
	//	*FromRadio_Packet
	//	*FromRadio_MyInfo
	//	*FromRadio_NodeInfo
	//	*FromRadio_Radio
	//	*FromRadio_DebugString
	//	*FromRadio_ConfigCompleteId
	//	*FromRadio_Rebooted
	Variant isFromRadio_Variant `protobuf_oneof:"variant"`
}

func (x *FromRadio) Reset() {
	*x = FromRadio{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FromRadio) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FromRadio) ProtoMessage() {}

func (x *FromRadio) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FromRadio.ProtoReflect.Descriptor instead.
func (*FromRadio) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{12}
}

func (x *FromRadio) GetNum() uint32 {
	if x != nil {
		return x.Num
	}
	return 0
}

func (m *FromRadio) GetVariant() isFromRadio_Variant {
	if m != nil {
		return m.Variant
	}
	return nil
}

func (x *FromRadio) GetPacket() *MeshPacket {
	if x, ok := x.GetVariant().(*FromRadio_Packet); ok {
		return x.Packet
	}
	return nil
}

func (x *FromRadio) GetMyInfo() *MyNodeInfo {
	if x, ok := x.GetVariant().(*FromRadio_MyInfo); ok {
		return x.MyInfo
	}
	return nil
}

func (x *FromRadio) GetNodeInfo() *NodeInfo {
	if x, ok := x.GetVariant().(*FromRadio_NodeInfo); ok {
		return x.NodeInfo
	}
	return nil
}

func (x *FromRadio) GetRadio() *RadioConfig {
	if x, ok := x.GetVariant().(*FromRadio_Radio); ok {
		return x.Radio
	}
	return nil
}

func (x *FromRadio) GetDebugString() *DebugString {
	if x, ok := x.GetVariant().(*FromRadio_DebugString); ok {
		return x.DebugString
	}
	return nil
}

func (x *FromRadio) GetConfigCompleteId() uint32 {
	if x, ok := x.GetVariant().(*FromRadio_ConfigCompleteId); ok {
		return x.ConfigCompleteId
	}
	return 0
}

func (x *FromRadio) GetRebooted() bool {
	if x, ok := x.GetVariant().(*FromRadio_Rebooted); ok {
		return x.Rebooted
	}
	return false
}

type isFromRadio_Variant interface {
	isFromRadio_Variant()
}

type FromRadio_Packet struct {
	Packet *MeshPacket `protobuf:"bytes,2,opt,name=packet,proto3,oneof"`
}

type FromRadio_MyInfo struct {
	/// Tells the phone what our node number is, can be -1 if we've not yet
	/// joined a mesh.
	// REV2: In the rev 1 API this is in the BLE mynodeinfo characteristic
	MyInfo *MyNodeInfo `protobuf:"bytes,3,opt,name=my_info,json=myInfo,proto3,oneof"`
}

type FromRadio_NodeInfo struct {
	/// One packet is sent for each node in the on radio DB
	// REV2: In the rev1 API this is available in the nodeinfo characteristic
	// starts over with the first node in our DB
	NodeInfo *NodeInfo `protobuf:"bytes,4,opt,name=node_info,json=nodeInfo,proto3,oneof"`
}

type FromRadio_Radio struct {
	/// REV2: In rev1 this was the radio BLE characteristic
	Radio *RadioConfig `protobuf:"bytes,6,opt,name=radio,proto3,oneof"`
}

type FromRadio_DebugString struct {
	/// REV2: set to send debug console output over our protobuf stream
	DebugString *DebugString `protobuf:"bytes,7,opt,name=debug_string,json=debugString,proto3,oneof"`
}

type FromRadio_ConfigCompleteId struct {
	/// REV2: sent as true once the device has finished sending all of the
	/// responses to want_config
	/// recipient should check if this ID matches our original request nonce, if
	/// not, it means your config responses haven't started yet
	ConfigCompleteId uint32 `protobuf:"varint,8,opt,name=config_complete_id,json=configCompleteId,proto3,oneof"`
}

type FromRadio_Rebooted struct {
	/// Sent to tell clients the radio has just rebooted.  Set to true if
	/// present.  Not used on all transports, currently just used for the serial
	/// console.
	Rebooted bool `protobuf:"varint,9,opt,name=rebooted,proto3,oneof"`
}

func (*FromRadio_Packet) isFromRadio_Variant() {}

func (*FromRadio_MyInfo) isFromRadio_Variant() {}

func (*FromRadio_NodeInfo) isFromRadio_Variant() {}

func (*FromRadio_Radio) isFromRadio_Variant() {}

func (*FromRadio_DebugString) isFromRadio_Variant() {}

func (*FromRadio_ConfigCompleteId) isFromRadio_Variant() {}

func (*FromRadio_Rebooted) isFromRadio_Variant() {}

// packets/commands to the radio will be written (reliably) to the toRadio
// characteristic.  Once the write completes the phone can assume it is handled.
type ToRadio struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Variant:
	//	*ToRadio_Packet
	//	*ToRadio_WantConfigId
	//	*ToRadio_SetRadio
	//	*ToRadio_SetOwner
	Variant isToRadio_Variant `protobuf_oneof:"variant"`
}

func (x *ToRadio) Reset() {
	*x = ToRadio{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ToRadio) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ToRadio) ProtoMessage() {}

func (x *ToRadio) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ToRadio.ProtoReflect.Descriptor instead.
func (*ToRadio) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{13}
}

func (m *ToRadio) GetVariant() isToRadio_Variant {
	if m != nil {
		return m.Variant
	}
	return nil
}

func (x *ToRadio) GetPacket() *MeshPacket {
	if x, ok := x.GetVariant().(*ToRadio_Packet); ok {
		return x.Packet
	}
	return nil
}

func (x *ToRadio) GetWantConfigId() uint32 {
	if x, ok := x.GetVariant().(*ToRadio_WantConfigId); ok {
		return x.WantConfigId
	}
	return 0
}

func (x *ToRadio) GetSetRadio() *RadioConfig {
	if x, ok := x.GetVariant().(*ToRadio_SetRadio); ok {
		return x.SetRadio
	}
	return nil
}

func (x *ToRadio) GetSetOwner() *User {
	if x, ok := x.GetVariant().(*ToRadio_SetOwner); ok {
		return x.SetOwner
	}
	return nil
}

type isToRadio_Variant interface {
	isToRadio_Variant()
}

type ToRadio_Packet struct {
	Packet *MeshPacket `protobuf:"bytes,1,opt,name=packet,proto3,oneof"` // send this packet on the mesh
}

type ToRadio_WantConfigId struct {
	/// REV2: phone wants radio to send full node db to the phone, This is
	/// typically the first packet sent to the radio when the phone gets a
	/// bluetooth connection. The radio will respond by sending back a
	/// MyNodeInfo, a owner, a radio config and a series of
	/// FromRadio.node_infos, and config_complete
	/// the integer you write into this field will be reported back in the
	/// config_complete_id response this allows clients to never be confused by
	/// a stale old partially sent config.
	WantConfigId uint32 `protobuf:"varint,100,opt,name=want_config_id,json=wantConfigId,proto3,oneof"`
}

type ToRadio_SetRadio struct {
	/// REV2: In rev1 this was the radio config characteristic
	SetRadio *RadioConfig `protobuf:"bytes,101,opt,name=set_radio,json=setRadio,proto3,oneof"` // set the radio provisioning for this node
}

type ToRadio_SetOwner struct {
	/// REV2: In rev1 this was the owner characteristic
	SetOwner *User `protobuf:"bytes,102,opt,name=set_owner,json=setOwner,proto3,oneof"` // Set the owner for this node
}

func (*ToRadio_Packet) isToRadio_Variant() {}

func (*ToRadio_WantConfigId) isToRadio_Variant() {}

func (*ToRadio_SetRadio) isToRadio_Variant() {}

func (*ToRadio_SetOwner) isToRadio_Variant() {}

//*
//Placeholder for data we will eventually set during initial programming.  This
//will allow us to stop having a load for each region.
type ManufacturingData struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	/// center frequency for the radio hardware that was stuffed
	FradioFreq uint32 `protobuf:"varint,1,opt,name=fradioFreq,proto3" json:"fradioFreq,omitempty"`
	/// TBEAM, HELTEC, etc...
	HwModel string `protobuf:"bytes,2,opt,name=hw_model,json=hwModel,proto3" json:"hw_model,omitempty"`
	// Hardware version number
	HwVersion string `protobuf:"bytes,3,opt,name=hw_version,json=hwVersion,proto3" json:"hw_version,omitempty"`
	//*
	//This code is written during manfacturing time and allows users to confirm that
	//the initial manufacturing tests succeeded.
	//
	//0 means no test performed.
	//1 means all tests passed
	//negative numbers indicate particular error codes
	SelftestResult int32 `protobuf:"zigzag32,4,opt,name=selftest_result,json=selftestResult,proto3" json:"selftest_result,omitempty"`
}

func (x *ManufacturingData) Reset() {
	*x = ManufacturingData{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ManufacturingData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ManufacturingData) ProtoMessage() {}

func (x *ManufacturingData) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ManufacturingData.ProtoReflect.Descriptor instead.
func (*ManufacturingData) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{14}
}

func (x *ManufacturingData) GetFradioFreq() uint32 {
	if x != nil {
		return x.FradioFreq
	}
	return 0
}

func (x *ManufacturingData) GetHwModel() string {
	if x != nil {
		return x.HwModel
	}
	return ""
}

func (x *ManufacturingData) GetHwVersion() string {
	if x != nil {
		return x.HwVersion
	}
	return ""
}

func (x *ManufacturingData) GetSelftestResult() int32 {
	if x != nil {
		return x.SelftestResult
	}
	return 0
}

type RadioConfig_UserPreferences struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// We should send our position this often (but only if it has changed
	// significantly)
	PositionBroadcastSecs uint32 `protobuf:"varint,1,opt,name=position_broadcast_secs,json=positionBroadcastSecs,proto3" json:"position_broadcast_secs,omitempty"`
	// Send our owner info at least this often (also we always send once at boot
	// - to rejoin the mesh)
	SendOwnerInterval uint32 `protobuf:"varint,2,opt,name=send_owner_interval,json=sendOwnerInterval,proto3" json:"send_owner_interval,omitempty"`
	/// If we miss this many owner messages from a node, we declare the node
	/// offline (defaults to 3 - to allow for some lost packets)
	NumMissedToFail uint32 `protobuf:"varint,3,opt,name=num_missed_to_fail,json=numMissedToFail,proto3" json:"num_missed_to_fail,omitempty"`
	/// see sw-design.md
	WaitBluetoothSecs  uint32 `protobuf:"varint,4,opt,name=wait_bluetooth_secs,json=waitBluetoothSecs,proto3" json:"wait_bluetooth_secs,omitempty"`
	ScreenOnSecs       uint32 `protobuf:"varint,5,opt,name=screen_on_secs,json=screenOnSecs,proto3" json:"screen_on_secs,omitempty"`
	PhoneTimeoutSecs   uint32 `protobuf:"varint,6,opt,name=phone_timeout_secs,json=phoneTimeoutSecs,proto3" json:"phone_timeout_secs,omitempty"`
	PhoneSdsTimeoutSec uint32 `protobuf:"varint,7,opt,name=phone_sds_timeout_sec,json=phoneSdsTimeoutSec,proto3" json:"phone_sds_timeout_sec,omitempty"`
	MeshSdsTimeoutSecs uint32 `protobuf:"varint,8,opt,name=mesh_sds_timeout_secs,json=meshSdsTimeoutSecs,proto3" json:"mesh_sds_timeout_secs,omitempty"`
	SdsSecs            uint32 `protobuf:"varint,9,opt,name=sds_secs,json=sdsSecs,proto3" json:"sds_secs,omitempty"`
	LsSecs             uint32 `protobuf:"varint,10,opt,name=ls_secs,json=lsSecs,proto3" json:"ls_secs,omitempty"`
	MinWakeSecs        uint32 `protobuf:"varint,11,opt,name=min_wake_secs,json=minWakeSecs,proto3" json:"min_wake_secs,omitempty"`
	//* If set, this node will try to join the specified wifi network and acquire an address via DHCP
	WifiSsid string `protobuf:"bytes,12,opt,name=wifi_ssid,json=wifiSsid,proto3" json:"wifi_ssid,omitempty"`
	//* If set, will be use to authenticate to the named wifi
	WifiPassword string `protobuf:"bytes,13,opt,name=wifi_password,json=wifiPassword,proto3" json:"wifi_password,omitempty"`
	//* If set, the node will operate as an AP (and DHCP server), otherwise it will be a station
	WifiApMode bool `protobuf:"varint,14,opt,name=wifi_ap_mode,json=wifiApMode,proto3" json:"wifi_ap_mode,omitempty"`
	//*
	//For testing it is useful sometimes to force a node to never listen to
	//particular other nodes (simulating radio out of range). All nodenums listed
	//in ignore_incoming will have packets they send droped on receive (by
	//router.cpp)
	IgnoreIncoming []uint32 `protobuf:"varint,102,rep,packed,name=ignore_incoming,json=ignoreIncoming,proto3" json:"ignore_incoming,omitempty"`
}

func (x *RadioConfig_UserPreferences) Reset() {
	*x = RadioConfig_UserPreferences{}
	if protoimpl.UnsafeEnabled {
		mi := &file_mesh_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RadioConfig_UserPreferences) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RadioConfig_UserPreferences) ProtoMessage() {}

func (x *RadioConfig_UserPreferences) ProtoReflect() protoreflect.Message {
	mi := &file_mesh_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RadioConfig_UserPreferences.ProtoReflect.Descriptor instead.
func (*RadioConfig_UserPreferences) Descriptor() ([]byte, []int) {
	return file_mesh_proto_rawDescGZIP(), []int{7, 0}
}

func (x *RadioConfig_UserPreferences) GetPositionBroadcastSecs() uint32 {
	if x != nil {
		return x.PositionBroadcastSecs
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetSendOwnerInterval() uint32 {
	if x != nil {
		return x.SendOwnerInterval
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetNumMissedToFail() uint32 {
	if x != nil {
		return x.NumMissedToFail
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetWaitBluetoothSecs() uint32 {
	if x != nil {
		return x.WaitBluetoothSecs
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetScreenOnSecs() uint32 {
	if x != nil {
		return x.ScreenOnSecs
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetPhoneTimeoutSecs() uint32 {
	if x != nil {
		return x.PhoneTimeoutSecs
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetPhoneSdsTimeoutSec() uint32 {
	if x != nil {
		return x.PhoneSdsTimeoutSec
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetMeshSdsTimeoutSecs() uint32 {
	if x != nil {
		return x.MeshSdsTimeoutSecs
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetSdsSecs() uint32 {
	if x != nil {
		return x.SdsSecs
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetLsSecs() uint32 {
	if x != nil {
		return x.LsSecs
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetMinWakeSecs() uint32 {
	if x != nil {
		return x.MinWakeSecs
	}
	return 0
}

func (x *RadioConfig_UserPreferences) GetWifiSsid() string {
	if x != nil {
		return x.WifiSsid
	}
	return ""
}

func (x *RadioConfig_UserPreferences) GetWifiPassword() string {
	if x != nil {
		return x.WifiPassword
	}
	return ""
}

func (x *RadioConfig_UserPreferences) GetWifiApMode() bool {
	if x != nil {
		return x.WifiApMode
	}
	return false
}

func (x *RadioConfig_UserPreferences) GetIgnoreIncoming() []uint32 {
	if x != nil {
		return x.IgnoreIncoming
	}
	return nil
}

var File_mesh_proto protoreflect.FileDescriptor

var file_mesh_proto_rawDesc = []byte{
	0x0a, 0x0a, 0x6d, 0x65, 0x73, 0x68, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x9f, 0x01, 0x0a,
	0x08, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1d, 0x0a, 0x0a, 0x6c, 0x61, 0x74,
	0x69, 0x74, 0x75, 0x64, 0x65, 0x5f, 0x69, 0x18, 0x07, 0x20, 0x01, 0x28, 0x11, 0x52, 0x09, 0x6c,
	0x61, 0x74, 0x69, 0x74, 0x75, 0x64, 0x65, 0x49, 0x12, 0x1f, 0x0a, 0x0b, 0x6c, 0x6f, 0x6e, 0x67,
	0x69, 0x74, 0x75, 0x64, 0x65, 0x5f, 0x69, 0x18, 0x08, 0x20, 0x01, 0x28, 0x11, 0x52, 0x0a, 0x6c,
	0x6f, 0x6e, 0x67, 0x69, 0x74, 0x75, 0x64, 0x65, 0x49, 0x12, 0x1a, 0x0a, 0x08, 0x61, 0x6c, 0x74,
	0x69, 0x74, 0x75, 0x64, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x61, 0x6c, 0x74,
	0x69, 0x74, 0x75, 0x64, 0x65, 0x12, 0x23, 0x0a, 0x0d, 0x62, 0x61, 0x74, 0x74, 0x65, 0x72, 0x79,
	0x5f, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0c, 0x62, 0x61,
	0x74, 0x74, 0x65, 0x72, 0x79, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x69,
	0x6d, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x07, 0x52, 0x04, 0x74, 0x69, 0x6d, 0x65, 0x22, 0x75,
	0x0a, 0x04, 0x44, 0x61, 0x74, 0x61, 0x12, 0x1c, 0x0a, 0x03, 0x74, 0x79, 0x70, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0e, 0x32, 0x0a, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x2e, 0x54, 0x79, 0x70, 0x65, 0x52,
	0x03, 0x74, 0x79, 0x70, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x07, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x22, 0x35,
	0x0a, 0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x0a, 0x0a, 0x06, 0x4f, 0x50, 0x41, 0x51, 0x55, 0x45,
	0x10, 0x00, 0x12, 0x0e, 0x0a, 0x0a, 0x43, 0x4c, 0x45, 0x41, 0x52, 0x5f, 0x54, 0x45, 0x58, 0x54,
	0x10, 0x01, 0x12, 0x11, 0x0a, 0x0d, 0x43, 0x4c, 0x45, 0x41, 0x52, 0x5f, 0x52, 0x45, 0x41, 0x44,
	0x41, 0x43, 0x4b, 0x10, 0x02, 0x22, 0x6c, 0x0a, 0x04, 0x55, 0x73, 0x65, 0x72, 0x12, 0x0e, 0x0a,
	0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x1b, 0x0a,
	0x09, 0x6c, 0x6f, 0x6e, 0x67, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x08, 0x6c, 0x6f, 0x6e, 0x67, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x1d, 0x0a, 0x0a, 0x73, 0x68,
	0x6f, 0x72, 0x74, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09,
	0x73, 0x68, 0x6f, 0x72, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x61, 0x63,
	0x61, 0x64, 0x64, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x07, 0x6d, 0x61, 0x63, 0x61,
	0x64, 0x64, 0x72, 0x22, 0x26, 0x0a, 0x0e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x44, 0x69, 0x73, 0x63,
	0x6f, 0x76, 0x65, 0x72, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x18, 0x02,
	0x20, 0x03, 0x28, 0x05, 0x52, 0x05, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x22, 0xca, 0x03, 0x0a, 0x09,
	0x53, 0x75, 0x62, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x12, 0x27, 0x0a, 0x08, 0x70, 0x6f, 0x73,
	0x69, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x09, 0x2e, 0x50, 0x6f,
	0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x08, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69,
	0x6f, 0x6e, 0x12, 0x1b, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x05, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x48, 0x00, 0x52, 0x04, 0x64, 0x61, 0x74, 0x61, 0x12,
	0x1b, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x05, 0x2e,
	0x55, 0x73, 0x65, 0x72, 0x48, 0x00, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x12, 0x36, 0x0a, 0x0d,
	0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x18, 0x06, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x44, 0x69, 0x73, 0x63, 0x6f,
	0x76, 0x65, 0x72, 0x79, 0x48, 0x00, 0x52, 0x0c, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x12, 0x32, 0x0a, 0x0b, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f, 0x72, 0x65,
	0x70, 0x6c, 0x79, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x52, 0x6f, 0x75, 0x74,
	0x65, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x48, 0x00, 0x52, 0x0a, 0x72, 0x6f,
	0x75, 0x74, 0x65, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x12, 0x2e, 0x0a, 0x0b, 0x72, 0x6f, 0x75, 0x74,
	0x65, 0x5f, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0b, 0x2e,
	0x52, 0x6f, 0x75, 0x74, 0x65, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x48, 0x00, 0x52, 0x0a, 0x72, 0x6f,
	0x75, 0x74, 0x65, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x12, 0x23, 0x0a, 0x0d, 0x77, 0x61, 0x6e, 0x74,
	0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x0c, 0x77, 0x61, 0x6e, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x1f, 0x0a,
	0x0a, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x5f, 0x69, 0x64, 0x18, 0x0a, 0x20, 0x01, 0x28,
	0x0d, 0x48, 0x01, 0x52, 0x09, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x49, 0x64, 0x12, 0x19,
	0x0a, 0x07, 0x66, 0x61, 0x69, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0d, 0x48,
	0x01, 0x52, 0x06, 0x66, 0x61, 0x69, 0x6c, 0x49, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x64, 0x65, 0x73,
	0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x04, 0x64, 0x65, 0x73, 0x74, 0x12, 0x16, 0x0a,
	0x06, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x73,
	0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x1f, 0x0a, 0x0b, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x61,
	0x6c, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x6f, 0x72, 0x69, 0x67,
	0x69, 0x6e, 0x61, 0x6c, 0x49, 0x64, 0x42, 0x09, 0x0a, 0x07, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61,
	0x64, 0x42, 0x05, 0x0a, 0x03, 0x61, 0x63, 0x6b, 0x22, 0xfb, 0x01, 0x0a, 0x0a, 0x4d, 0x65, 0x73,
	0x68, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x12, 0x0e, 0x0a, 0x02, 0x74,
	0x6f, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x02, 0x74, 0x6f, 0x12, 0x26, 0x0a, 0x07, 0x64,
	0x65, 0x63, 0x6f, 0x64, 0x65, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0a, 0x2e, 0x53,
	0x75, 0x62, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x48, 0x00, 0x52, 0x07, 0x64, 0x65, 0x63, 0x6f,
	0x64, 0x65, 0x64, 0x12, 0x1e, 0x0a, 0x09, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64,
	0x18, 0x08, 0x20, 0x01, 0x28, 0x0c, 0x48, 0x00, 0x52, 0x09, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70,
	0x74, 0x65, 0x64, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x52,
	0x02, 0x69, 0x64, 0x12, 0x17, 0x0a, 0x07, 0x72, 0x78, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x09,
	0x20, 0x01, 0x28, 0x07, 0x52, 0x06, 0x72, 0x78, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x15, 0x0a, 0x06,
	0x72, 0x78, 0x5f, 0x73, 0x6e, 0x72, 0x18, 0x07, 0x20, 0x01, 0x28, 0x02, 0x52, 0x05, 0x72, 0x78,
	0x53, 0x6e, 0x72, 0x12, 0x1b, 0x0a, 0x09, 0x68, 0x6f, 0x70, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74,
	0x18, 0x0a, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x08, 0x68, 0x6f, 0x70, 0x4c, 0x69, 0x6d, 0x69, 0x74,
	0x12, 0x19, 0x0a, 0x08, 0x77, 0x61, 0x6e, 0x74, 0x5f, 0x61, 0x63, 0x6b, 0x18, 0x0b, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x07, 0x77, 0x61, 0x6e, 0x74, 0x41, 0x63, 0x6b, 0x42, 0x09, 0x0a, 0x07, 0x70,
	0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x22, 0xf5, 0x01, 0x0a, 0x0f, 0x43, 0x68, 0x61, 0x6e, 0x6e,
	0x65, 0x6c, 0x53, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x73, 0x12, 0x19, 0x0a, 0x08, 0x74, 0x78,
	0x5f, 0x70, 0x6f, 0x77, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x07, 0x74, 0x78,
	0x50, 0x6f, 0x77, 0x65, 0x72, 0x12, 0x3f, 0x0a, 0x0c, 0x6d, 0x6f, 0x64, 0x65, 0x6d, 0x5f, 0x63,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1c, 0x2e, 0x43, 0x68,
	0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x53, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x73, 0x2e, 0x4d, 0x6f,
	0x64, 0x65, 0x6d, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0b, 0x6d, 0x6f, 0x64, 0x65, 0x6d,
	0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x10, 0x0a, 0x03, 0x70, 0x73, 0x6b, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x0c, 0x52, 0x03, 0x70, 0x73, 0x6b, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x60, 0x0a, 0x0b,
	0x4d, 0x6f, 0x64, 0x65, 0x6d, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x12, 0x0a, 0x0e, 0x42,
	0x77, 0x31, 0x32, 0x35, 0x43, 0x72, 0x34, 0x35, 0x53, 0x66, 0x31, 0x32, 0x38, 0x10, 0x00, 0x12,
	0x12, 0x0a, 0x0e, 0x42, 0x77, 0x35, 0x30, 0x30, 0x43, 0x72, 0x34, 0x35, 0x53, 0x66, 0x31, 0x32,
	0x38, 0x10, 0x01, 0x12, 0x14, 0x0a, 0x10, 0x42, 0x77, 0x33, 0x31, 0x5f, 0x32, 0x35, 0x43, 0x72,
	0x34, 0x38, 0x53, 0x66, 0x35, 0x31, 0x32, 0x10, 0x02, 0x12, 0x13, 0x0a, 0x0f, 0x42, 0x77, 0x31,
	0x32, 0x35, 0x43, 0x72, 0x34, 0x38, 0x53, 0x66, 0x34, 0x30, 0x39, 0x36, 0x10, 0x03, 0x22, 0x82,
	0x06, 0x0a, 0x0b, 0x52, 0x61, 0x64, 0x69, 0x6f, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x3e,
	0x0a, 0x0b, 0x70, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x73, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x52, 0x61, 0x64, 0x69, 0x6f, 0x43, 0x6f, 0x6e, 0x66, 0x69,
	0x67, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x50, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65,
	0x73, 0x52, 0x0b, 0x70, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x73, 0x12, 0x3b,
	0x0a, 0x10, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x73, 0x65, 0x74, 0x74, 0x69, 0x6e,
	0x67, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x43, 0x68, 0x61, 0x6e, 0x6e,
	0x65, 0x6c, 0x53, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x73, 0x52, 0x0f, 0x63, 0x68, 0x61, 0x6e,
	0x6e, 0x65, 0x6c, 0x53, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x73, 0x1a, 0xf5, 0x04, 0x0a, 0x0f,
	0x55, 0x73, 0x65, 0x72, 0x50, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x73, 0x12,
	0x36, 0x0a, 0x17, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x62, 0x72, 0x6f, 0x61,
	0x64, 0x63, 0x61, 0x73, 0x74, 0x5f, 0x73, 0x65, 0x63, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x15, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x42, 0x72, 0x6f, 0x61, 0x64, 0x63,
	0x61, 0x73, 0x74, 0x53, 0x65, 0x63, 0x73, 0x12, 0x2e, 0x0a, 0x13, 0x73, 0x65, 0x6e, 0x64, 0x5f,
	0x6f, 0x77, 0x6e, 0x65, 0x72, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x11, 0x73, 0x65, 0x6e, 0x64, 0x4f, 0x77, 0x6e, 0x65, 0x72, 0x49,
	0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x12, 0x2b, 0x0a, 0x12, 0x6e, 0x75, 0x6d, 0x5f, 0x6d,
	0x69, 0x73, 0x73, 0x65, 0x64, 0x5f, 0x74, 0x6f, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x0d, 0x52, 0x0f, 0x6e, 0x75, 0x6d, 0x4d, 0x69, 0x73, 0x73, 0x65, 0x64, 0x54, 0x6f,
	0x46, 0x61, 0x69, 0x6c, 0x12, 0x2e, 0x0a, 0x13, 0x77, 0x61, 0x69, 0x74, 0x5f, 0x62, 0x6c, 0x75,
	0x65, 0x74, 0x6f, 0x6f, 0x74, 0x68, 0x5f, 0x73, 0x65, 0x63, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x0d, 0x52, 0x11, 0x77, 0x61, 0x69, 0x74, 0x42, 0x6c, 0x75, 0x65, 0x74, 0x6f, 0x6f, 0x74, 0x68,
	0x53, 0x65, 0x63, 0x73, 0x12, 0x24, 0x0a, 0x0e, 0x73, 0x63, 0x72, 0x65, 0x65, 0x6e, 0x5f, 0x6f,
	0x6e, 0x5f, 0x73, 0x65, 0x63, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0c, 0x73, 0x63,
	0x72, 0x65, 0x65, 0x6e, 0x4f, 0x6e, 0x53, 0x65, 0x63, 0x73, 0x12, 0x2c, 0x0a, 0x12, 0x70, 0x68,
	0x6f, 0x6e, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f, 0x73, 0x65, 0x63, 0x73,
	0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x10, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x54, 0x69, 0x6d,
	0x65, 0x6f, 0x75, 0x74, 0x53, 0x65, 0x63, 0x73, 0x12, 0x31, 0x0a, 0x15, 0x70, 0x68, 0x6f, 0x6e,
	0x65, 0x5f, 0x73, 0x64, 0x73, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f, 0x73, 0x65,
	0x63, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x12, 0x70, 0x68, 0x6f, 0x6e, 0x65, 0x53, 0x64,
	0x73, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x53, 0x65, 0x63, 0x12, 0x31, 0x0a, 0x15, 0x6d,
	0x65, 0x73, 0x68, 0x5f, 0x73, 0x64, 0x73, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f,
	0x73, 0x65, 0x63, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x12, 0x6d, 0x65, 0x73, 0x68,
	0x53, 0x64, 0x73, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x53, 0x65, 0x63, 0x73, 0x12, 0x19,
	0x0a, 0x08, 0x73, 0x64, 0x73, 0x5f, 0x73, 0x65, 0x63, 0x73, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x07, 0x73, 0x64, 0x73, 0x53, 0x65, 0x63, 0x73, 0x12, 0x17, 0x0a, 0x07, 0x6c, 0x73, 0x5f,
	0x73, 0x65, 0x63, 0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x6c, 0x73, 0x53, 0x65,
	0x63, 0x73, 0x12, 0x22, 0x0a, 0x0d, 0x6d, 0x69, 0x6e, 0x5f, 0x77, 0x61, 0x6b, 0x65, 0x5f, 0x73,
	0x65, 0x63, 0x73, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0b, 0x6d, 0x69, 0x6e, 0x57, 0x61,
	0x6b, 0x65, 0x53, 0x65, 0x63, 0x73, 0x12, 0x1b, 0x0a, 0x09, 0x77, 0x69, 0x66, 0x69, 0x5f, 0x73,
	0x73, 0x69, 0x64, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x77, 0x69, 0x66, 0x69, 0x53,
	0x73, 0x69, 0x64, 0x12, 0x23, 0x0a, 0x0d, 0x77, 0x69, 0x66, 0x69, 0x5f, 0x70, 0x61, 0x73, 0x73,
	0x77, 0x6f, 0x72, 0x64, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x77, 0x69, 0x66, 0x69,
	0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x12, 0x20, 0x0a, 0x0c, 0x77, 0x69, 0x66, 0x69,
	0x5f, 0x61, 0x70, 0x5f, 0x6d, 0x6f, 0x64, 0x65, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a,
	0x77, 0x69, 0x66, 0x69, 0x41, 0x70, 0x4d, 0x6f, 0x64, 0x65, 0x12, 0x27, 0x0a, 0x0f, 0x69, 0x67,
	0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x18, 0x66, 0x20,
	0x03, 0x28, 0x0d, 0x52, 0x0e, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x49, 0x6e, 0x63, 0x6f, 0x6d,
	0x69, 0x6e, 0x67, 0x22, 0x8b, 0x01, 0x0a, 0x08, 0x4e, 0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f,
	0x12, 0x10, 0x0a, 0x03, 0x6e, 0x75, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x03, 0x6e,
	0x75, 0x6d, 0x12, 0x19, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x05, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x12, 0x25, 0x0a,
	0x08, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x09, 0x2e, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x08, 0x70, 0x6f, 0x73, 0x69,
	0x74, 0x69, 0x6f, 0x6e, 0x12, 0x10, 0x0a, 0x03, 0x73, 0x6e, 0x72, 0x18, 0x07, 0x20, 0x01, 0x28,
	0x02, 0x52, 0x03, 0x73, 0x6e, 0x72, 0x12, 0x19, 0x0a, 0x08, 0x6e, 0x65, 0x78, 0x74, 0x5f, 0x68,
	0x6f, 0x70, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x07, 0x6e, 0x65, 0x78, 0x74, 0x48, 0x6f,
	0x70, 0x22, 0xfb, 0x03, 0x0a, 0x0a, 0x4d, 0x79, 0x4e, 0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f,
	0x12, 0x1e, 0x0a, 0x0b, 0x6d, 0x79, 0x5f, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x6e, 0x75, 0x6d, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x6d, 0x79, 0x4e, 0x6f, 0x64, 0x65, 0x4e, 0x75, 0x6d,
	0x12, 0x17, 0x0a, 0x07, 0x68, 0x61, 0x73, 0x5f, 0x67, 0x70, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x06, 0x68, 0x61, 0x73, 0x47, 0x70, 0x73, 0x12, 0x21, 0x0a, 0x0c, 0x6e, 0x75, 0x6d,
	0x5f, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52,
	0x0b, 0x6e, 0x75, 0x6d, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x12, 0x16, 0x0a, 0x06,
	0x72, 0x65, 0x67, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x72, 0x65,
	0x67, 0x69, 0x6f, 0x6e, 0x12, 0x19, 0x0a, 0x08, 0x68, 0x77, 0x5f, 0x6d, 0x6f, 0x64, 0x65, 0x6c,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x68, 0x77, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x12,
	0x29, 0x0a, 0x10, 0x66, 0x69, 0x72, 0x6d, 0x77, 0x61, 0x72, 0x65, 0x5f, 0x76, 0x65, 0x72, 0x73,
	0x69, 0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x66, 0x69, 0x72, 0x6d, 0x77,
	0x61, 0x72, 0x65, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x1d, 0x0a, 0x0a, 0x65, 0x72,
	0x72, 0x6f, 0x72, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09,
	0x65, 0x72, 0x72, 0x6f, 0x72, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x23, 0x0a, 0x0d, 0x65, 0x72, 0x72,
	0x6f, 0x72, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x0c, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x1f,
	0x0a, 0x0b, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x09, 0x20,
	0x01, 0x28, 0x0d, 0x52, 0x0a, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12,
	0x24, 0x0a, 0x0e, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x5f, 0x69, 0x64, 0x5f, 0x62, 0x69, 0x74,
	0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0c, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x49,
	0x64, 0x42, 0x69, 0x74, 0x73, 0x12, 0x2a, 0x0a, 0x11, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74,
	0x5f, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x0f, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x49,
	0x64, 0x12, 0x22, 0x0a, 0x0d, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x6e, 0x75, 0x6d, 0x5f, 0x62, 0x69,
	0x74, 0x73, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0b, 0x6e, 0x6f, 0x64, 0x65, 0x4e, 0x75,
	0x6d, 0x42, 0x69, 0x74, 0x73, 0x12, 0x30, 0x0a, 0x14, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
	0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f, 0x6d, 0x73, 0x65, 0x63, 0x18, 0x0d, 0x20,
	0x01, 0x28, 0x0d, 0x52, 0x12, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x54, 0x69, 0x6d, 0x65,
	0x6f, 0x75, 0x74, 0x4d, 0x73, 0x65, 0x63, 0x12, 0x26, 0x0a, 0x0f, 0x6d, 0x69, 0x6e, 0x5f, 0x61,
	0x70, 0x70, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x0d, 0x6d, 0x69, 0x6e, 0x41, 0x70, 0x70, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22,
	0xb2, 0x02, 0x0a, 0x0b, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12,
	0x22, 0x0a, 0x05, 0x72, 0x61, 0x64, 0x69, 0x6f, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0c,
	0x2e, 0x52, 0x61, 0x64, 0x69, 0x6f, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x05, 0x72, 0x61,
	0x64, 0x69, 0x6f, 0x12, 0x24, 0x0a, 0x07, 0x6d, 0x79, 0x5f, 0x6e, 0x6f, 0x64, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x4d, 0x79, 0x4e, 0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66,
	0x6f, 0x52, 0x06, 0x6d, 0x79, 0x4e, 0x6f, 0x64, 0x65, 0x12, 0x1b, 0x0a, 0x05, 0x6f, 0x77, 0x6e,
	0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x05, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52,
	0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x12, 0x22, 0x0a, 0x07, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x64,
	0x62, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x09, 0x2e, 0x4e, 0x6f, 0x64, 0x65, 0x49, 0x6e,
	0x66, 0x6f, 0x52, 0x06, 0x6e, 0x6f, 0x64, 0x65, 0x44, 0x62, 0x12, 0x30, 0x0a, 0x0d, 0x72, 0x65,
	0x63, 0x65, 0x69, 0x76, 0x65, 0x5f, 0x71, 0x75, 0x65, 0x75, 0x65, 0x18, 0x05, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x0b, 0x2e, 0x4d, 0x65, 0x73, 0x68, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x52, 0x0c,
	0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x51, 0x75, 0x65, 0x75, 0x65, 0x12, 0x18, 0x0a, 0x07,
	0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x07, 0x76,
	0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x33, 0x0a, 0x0f, 0x72, 0x78, 0x5f, 0x74, 0x65, 0x78,
	0x74, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x0b, 0x2e, 0x4d, 0x65, 0x73, 0x68, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x52, 0x0d, 0x72, 0x78,
	0x54, 0x65, 0x78, 0x74, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x17, 0x0a, 0x07, 0x6e,
	0x6f, 0x5f, 0x73, 0x61, 0x76, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x6e, 0x6f,
	0x53, 0x61, 0x76, 0x65, 0x22, 0x27, 0x0a, 0x0b, 0x44, 0x65, 0x62, 0x75, 0x67, 0x53, 0x74, 0x72,
	0x69, 0x6e, 0x67, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0xc8, 0x02,
	0x0a, 0x09, 0x46, 0x72, 0x6f, 0x6d, 0x52, 0x61, 0x64, 0x69, 0x6f, 0x12, 0x10, 0x0a, 0x03, 0x6e,
	0x75, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x03, 0x6e, 0x75, 0x6d, 0x12, 0x25, 0x0a,
	0x06, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b, 0x2e,
	0x4d, 0x65, 0x73, 0x68, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x48, 0x00, 0x52, 0x06, 0x70, 0x61,
	0x63, 0x6b, 0x65, 0x74, 0x12, 0x26, 0x0a, 0x07, 0x6d, 0x79, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x4d, 0x79, 0x4e, 0x6f, 0x64, 0x65, 0x49, 0x6e,
	0x66, 0x6f, 0x48, 0x00, 0x52, 0x06, 0x6d, 0x79, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x28, 0x0a, 0x09,
	0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x09, 0x2e, 0x4e, 0x6f, 0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x48, 0x00, 0x52, 0x08, 0x6e, 0x6f,
	0x64, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x24, 0x0a, 0x05, 0x72, 0x61, 0x64, 0x69, 0x6f, 0x18,
	0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x52, 0x61, 0x64, 0x69, 0x6f, 0x43, 0x6f, 0x6e,
	0x66, 0x69, 0x67, 0x48, 0x00, 0x52, 0x05, 0x72, 0x61, 0x64, 0x69, 0x6f, 0x12, 0x31, 0x0a, 0x0c,
	0x64, 0x65, 0x62, 0x75, 0x67, 0x5f, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x18, 0x07, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x44, 0x65, 0x62, 0x75, 0x67, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67,
	0x48, 0x00, 0x52, 0x0b, 0x64, 0x65, 0x62, 0x75, 0x67, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x12,
	0x2e, 0x0a, 0x12, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65,
	0x74, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0d, 0x48, 0x00, 0x52, 0x10, 0x63,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x43, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x49, 0x64, 0x12,
	0x1c, 0x0a, 0x08, 0x72, 0x65, 0x62, 0x6f, 0x6f, 0x74, 0x65, 0x64, 0x18, 0x09, 0x20, 0x01, 0x28,
	0x08, 0x48, 0x00, 0x52, 0x08, 0x72, 0x65, 0x62, 0x6f, 0x6f, 0x74, 0x65, 0x64, 0x42, 0x09, 0x0a,
	0x07, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x22, 0xb6, 0x01, 0x0a, 0x07, 0x54, 0x6f, 0x52,
	0x61, 0x64, 0x69, 0x6f, 0x12, 0x25, 0x0a, 0x06, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x4d, 0x65, 0x73, 0x68, 0x50, 0x61, 0x63, 0x6b, 0x65,
	0x74, 0x48, 0x00, 0x52, 0x06, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x12, 0x26, 0x0a, 0x0e, 0x77,
	0x61, 0x6e, 0x74, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x69, 0x64, 0x18, 0x64, 0x20,
	0x01, 0x28, 0x0d, 0x48, 0x00, 0x52, 0x0c, 0x77, 0x61, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69,
	0x67, 0x49, 0x64, 0x12, 0x2b, 0x0a, 0x09, 0x73, 0x65, 0x74, 0x5f, 0x72, 0x61, 0x64, 0x69, 0x6f,
	0x18, 0x65, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x52, 0x61, 0x64, 0x69, 0x6f, 0x43, 0x6f,
	0x6e, 0x66, 0x69, 0x67, 0x48, 0x00, 0x52, 0x08, 0x73, 0x65, 0x74, 0x52, 0x61, 0x64, 0x69, 0x6f,
	0x12, 0x24, 0x0a, 0x09, 0x73, 0x65, 0x74, 0x5f, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x18, 0x66, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x05, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x48, 0x00, 0x52, 0x08, 0x73, 0x65,
	0x74, 0x4f, 0x77, 0x6e, 0x65, 0x72, 0x42, 0x09, 0x0a, 0x07, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e,
	0x74, 0x22, 0x96, 0x01, 0x0a, 0x11, 0x4d, 0x61, 0x6e, 0x75, 0x66, 0x61, 0x63, 0x74, 0x75, 0x72,
	0x69, 0x6e, 0x67, 0x44, 0x61, 0x74, 0x61, 0x12, 0x1e, 0x0a, 0x0a, 0x66, 0x72, 0x61, 0x64, 0x69,
	0x6f, 0x46, 0x72, 0x65, 0x71, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x66, 0x72, 0x61,
	0x64, 0x69, 0x6f, 0x46, 0x72, 0x65, 0x71, 0x12, 0x19, 0x0a, 0x08, 0x68, 0x77, 0x5f, 0x6d, 0x6f,
	0x64, 0x65, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x68, 0x77, 0x4d, 0x6f, 0x64,
	0x65, 0x6c, 0x12, 0x1d, 0x0a, 0x0a, 0x68, 0x77, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x68, 0x77, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f,
	0x6e, 0x12, 0x27, 0x0a, 0x0f, 0x73, 0x65, 0x6c, 0x66, 0x74, 0x65, 0x73, 0x74, 0x5f, 0x72, 0x65,
	0x73, 0x75, 0x6c, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x11, 0x52, 0x0e, 0x73, 0x65, 0x6c, 0x66,
	0x74, 0x65, 0x73, 0x74, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x2a, 0x3e, 0x0a, 0x0a, 0x52, 0x6f,
	0x75, 0x74, 0x65, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x12, 0x08, 0x0a, 0x04, 0x4e, 0x4f, 0x4e, 0x45,
	0x10, 0x00, 0x12, 0x0c, 0x0a, 0x08, 0x4e, 0x4f, 0x5f, 0x52, 0x4f, 0x55, 0x54, 0x45, 0x10, 0x01,
	0x12, 0x0b, 0x0a, 0x07, 0x47, 0x4f, 0x54, 0x5f, 0x4e, 0x41, 0x4b, 0x10, 0x02, 0x12, 0x0b, 0x0a,
	0x07, 0x54, 0x49, 0x4d, 0x45, 0x4f, 0x55, 0x54, 0x10, 0x03, 0x2a, 0x17, 0x0a, 0x09, 0x43, 0x6f,
	0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x73, 0x12, 0x0a, 0x0a, 0x06, 0x55, 0x6e, 0x75, 0x73, 0x65,
	0x64, 0x10, 0x00, 0x42, 0x21, 0x0a, 0x13, 0x63, 0x6f, 0x6d, 0x2e, 0x67, 0x65, 0x65, 0x6b, 0x73,
	0x76, 0x69, 0x6c, 0x6c, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x68, 0x42, 0x0a, 0x4d, 0x65, 0x73, 0x68,
	0x50, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_mesh_proto_rawDescOnce sync.Once
	file_mesh_proto_rawDescData = file_mesh_proto_rawDesc
)

func file_mesh_proto_rawDescGZIP() []byte {
	file_mesh_proto_rawDescOnce.Do(func() {
		file_mesh_proto_rawDescData = protoimpl.X.CompressGZIP(file_mesh_proto_rawDescData)
	})
	return file_mesh_proto_rawDescData
}

var file_mesh_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_mesh_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_mesh_proto_goTypes = []interface{}{
	(RouteError)(0),                     // 0: RouteError
	(Constants)(0),                      // 1: Constants
	(Data_Type)(0),                      // 2: Data.Type
	(ChannelSettings_ModemConfig)(0),    // 3: ChannelSettings.ModemConfig
	(*Position)(nil),                    // 4: Position
	(*Data)(nil),                        // 5: Data
	(*User)(nil),                        // 6: User
	(*RouteDiscovery)(nil),              // 7: RouteDiscovery
	(*SubPacket)(nil),                   // 8: SubPacket
	(*MeshPacket)(nil),                  // 9: MeshPacket
	(*ChannelSettings)(nil),             // 10: ChannelSettings
	(*RadioConfig)(nil),                 // 11: RadioConfig
	(*NodeInfo)(nil),                    // 12: NodeInfo
	(*MyNodeInfo)(nil),                  // 13: MyNodeInfo
	(*DeviceState)(nil),                 // 14: DeviceState
	(*DebugString)(nil),                 // 15: DebugString
	(*FromRadio)(nil),                   // 16: FromRadio
	(*ToRadio)(nil),                     // 17: ToRadio
	(*ManufacturingData)(nil),           // 18: ManufacturingData
	(*RadioConfig_UserPreferences)(nil), // 19: RadioConfig.UserPreferences
}
var file_mesh_proto_depIdxs = []int32{
	2,  // 0: Data.typ:type_name -> Data.Type
	4,  // 1: SubPacket.position:type_name -> Position
	5,  // 2: SubPacket.data:type_name -> Data
	6,  // 3: SubPacket.user:type_name -> User
	7,  // 4: SubPacket.route_request:type_name -> RouteDiscovery
	7,  // 5: SubPacket.route_reply:type_name -> RouteDiscovery
	0,  // 6: SubPacket.route_error:type_name -> RouteError
	8,  // 7: MeshPacket.decoded:type_name -> SubPacket
	3,  // 8: ChannelSettings.modem_config:type_name -> ChannelSettings.ModemConfig
	19, // 9: RadioConfig.preferences:type_name -> RadioConfig.UserPreferences
	10, // 10: RadioConfig.channel_settings:type_name -> ChannelSettings
	6,  // 11: NodeInfo.user:type_name -> User
	4,  // 12: NodeInfo.position:type_name -> Position
	11, // 13: DeviceState.radio:type_name -> RadioConfig
	13, // 14: DeviceState.my_node:type_name -> MyNodeInfo
	6,  // 15: DeviceState.owner:type_name -> User
	12, // 16: DeviceState.node_db:type_name -> NodeInfo
	9,  // 17: DeviceState.receive_queue:type_name -> MeshPacket
	9,  // 18: DeviceState.rx_text_message:type_name -> MeshPacket
	9,  // 19: FromRadio.packet:type_name -> MeshPacket
	13, // 20: FromRadio.my_info:type_name -> MyNodeInfo
	12, // 21: FromRadio.node_info:type_name -> NodeInfo
	11, // 22: FromRadio.radio:type_name -> RadioConfig
	15, // 23: FromRadio.debug_string:type_name -> DebugString
	9,  // 24: ToRadio.packet:type_name -> MeshPacket
	11, // 25: ToRadio.set_radio:type_name -> RadioConfig
	6,  // 26: ToRadio.set_owner:type_name -> User
	27, // [27:27] is the sub-list for method output_type
	27, // [27:27] is the sub-list for method input_type
	27, // [27:27] is the sub-list for extension type_name
	27, // [27:27] is the sub-list for extension extendee
	0,  // [0:27] is the sub-list for field type_name
}

func init() { file_mesh_proto_init() }
func file_mesh_proto_init() {
	if File_mesh_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_mesh_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Position); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Data); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*User); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RouteDiscovery); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SubPacket); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MeshPacket); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ChannelSettings); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RadioConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NodeInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MyNodeInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DeviceState); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DebugString); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FromRadio); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ToRadio); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ManufacturingData); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_mesh_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RadioConfig_UserPreferences); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_mesh_proto_msgTypes[4].OneofWrappers = []interface{}{
		(*SubPacket_Position)(nil),
		(*SubPacket_Data)(nil),
		(*SubPacket_User)(nil),
		(*SubPacket_RouteRequest)(nil),
		(*SubPacket_RouteReply)(nil),
		(*SubPacket_RouteError)(nil),
		(*SubPacket_SuccessId)(nil),
		(*SubPacket_FailId)(nil),
	}
	file_mesh_proto_msgTypes[5].OneofWrappers = []interface{}{
		(*MeshPacket_Decoded)(nil),
		(*MeshPacket_Encrypted)(nil),
	}
	file_mesh_proto_msgTypes[12].OneofWrappers = []interface{}{
		(*FromRadio_Packet)(nil),
		(*FromRadio_MyInfo)(nil),
		(*FromRadio_NodeInfo)(nil),
		(*FromRadio_Radio)(nil),
		(*FromRadio_DebugString)(nil),
		(*FromRadio_ConfigCompleteId)(nil),
		(*FromRadio_Rebooted)(nil),
	}
	file_mesh_proto_msgTypes[13].OneofWrappers = []interface{}{
		(*ToRadio_Packet)(nil),
		(*ToRadio_WantConfigId)(nil),
		(*ToRadio_SetRadio)(nil),
		(*ToRadio_SetOwner)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_mesh_proto_rawDesc,
			NumEnums:      4,
			NumMessages:   16,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_mesh_proto_goTypes,
		DependencyIndexes: file_mesh_proto_depIdxs,
		EnumInfos:         file_mesh_proto_enumTypes,
		MessageInfos:      file_mesh_proto_msgTypes,
	}.Build()
	File_mesh_proto = out.File
	file_mesh_proto_rawDesc = nil
	file_mesh_proto_goTypes = nil
	file_mesh_proto_depIdxs = nil
}
